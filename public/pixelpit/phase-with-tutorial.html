<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>PHASE</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #0a0a0a;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      overflow: hidden;
      touch-action: none;
      font-family: monospace;
    }
    canvas { display: block; }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const T = {
      bg: '#0a0a0a',
      gear: '#2a2a2e',
      cyan: '#22d3ee',
      fuchsia: '#d946ef',
      gold: '#facc15',
      text: '#ffffff',
      grey: '#555555',
      slime: '#a3e635',
    };

    const PHASE_COLORS = [T.cyan, T.fuchsia, T.gold];

    let W, H;
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      W = canvas.width;
      H = canvas.height;
    }
    resize();
    window.addEventListener('resize', resize);

    // --- AUDIO ---
    let audioCtx;
    function initAudio() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === 'suspended') audioCtx.resume();
    }
    canvas.addEventListener('touchstart', initAudio, { once: true });
    canvas.addEventListener('click', initAudio, { once: true });

    const CHIME_FREQ = { [T.cyan]: 880, [T.fuchsia]: 587, [T.gold]: 392 };

    function playPhaseThrough(color) {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.connect(g); g.connect(audioCtx.destination);
      osc.type = 'sine';
      osc.frequency.value = CHIME_FREQ[color] || 660;
      g.gain.setValueAtTime(0.1, audioCtx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.25);
      osc.start(); osc.stop(audioCtx.currentTime + 0.25);
    }

    function playClank() {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.connect(g); g.connect(audioCtx.destination);
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(300, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(80, audioCtx.currentTime + 0.15);
      g.gain.setValueAtTime(0.2, audioCtx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);
      osc.start(); osc.stop(audioCtx.currentTime + 0.2);
      const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.1, audioCtx.sampleRate);
      const data = buf.getChannelData(0);
      for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * (1 - i / data.length);
      const src = audioCtx.createBufferSource();
      const ng = audioCtx.createGain();
      src.buffer = buf; src.connect(ng); ng.connect(audioCtx.destination);
      ng.gain.setValueAtTime(0.12, audioCtx.currentTime);
      ng.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
      src.start();
    }

    function playShift() {
      if (!audioCtx) return;
      for (let i = 0; i < 4; i++) {
        setTimeout(() => {
          if (!audioCtx) return;
          const osc = audioCtx.createOscillator();
          const g = audioCtx.createGain();
          osc.connect(g); g.connect(audioCtx.destination);
          osc.type = 'triangle';
          osc.frequency.value = 400 + i * 150;
          g.gain.setValueAtTime(0.08, audioCtx.currentTime);
          g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.12);
          osc.start(); osc.stop(audioCtx.currentTime + 0.12);
        }, i * 60);
      }
    }

    function playTap() {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.connect(g); g.connect(audioCtx.destination);
      osc.type = 'sine';
      osc.frequency.value = 440;
      g.gain.setValueAtTime(0.05, audioCtx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.06);
      osc.start(); osc.stop(audioCtx.currentTime + 0.06);
    }

    function playLevelUp() {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain); gain.connect(audioCtx.destination);
      osc.type = 'square';
      osc.frequency.setValueAtTime(300, audioCtx.currentTime);
      osc.frequency.linearRampToValueAtTime(600, audioCtx.currentTime + 0.2);
      gain.gain.setValueAtTime(0.12, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
      osc.start(); osc.stop(audioCtx.currentTime + 0.3);
    }

    // --- CLOCK TICK ---
    let tickInterval;
    function startTick(bpm) {
      stopTick();
      const ms = 60000 / bpm;
      tickInterval = setInterval(() => {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        osc.connect(g); g.connect(audioCtx.destination);
        osc.type = 'square';
        osc.frequency.value = 1200;
        g.gain.setValueAtTime(0.02, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.02);
        osc.start(); osc.stop(audioCtx.currentTime + 0.02);
      }, ms);
    }
    function stopTick() {
      if (tickInterval) { clearInterval(tickInterval); tickInterval = null; }
    }

    // --- GEAR GENERATION ---
    const GEAR_SPACING = 140;
    const GEAR_OUTER_R = 55;
    const GEAR_INNER_R = 20;
    const GRAVITY = 400;
    const TAP_IMPULSE = -220;
    const TERMINAL_VEL = 350;

    let currentPhaseColor;

    function createGear(index, phaseColor) {
      const color = phaseColor || currentPhaseColor;
      const numSegments = 4;
      const matchCount = index < 20 ? 2 : 1;
      const segments = [];
      const otherColors = PHASE_COLORS.filter(c => c !== color);
      const matchIndices = [];
      while (matchIndices.length < matchCount) {
        const idx = Math.floor(Math.random() * numSegments);
        if (!matchIndices.includes(idx)) matchIndices.push(idx);
      }
      for (let i = 0; i < numSegments; i++) {
        segments.push(matchIndices.includes(i) ? color : otherColors[Math.floor(Math.random() * otherColors.length)]);
      }
      const baseSpeed = 0.8 + Math.min(index * 0.04, 1.5);
      const dir = Math.random() < 0.5 ? 1 : -1;
      return {
        index, x: W / 2, y: 0,
        angle: Math.random() * Math.PI * 2,
        speed: baseSpeed * dir,
        segments, numSegments, passed: false,
      };
    }

    function getGearWorldY(gear) {
      return 250 + gear.index * GEAR_SPACING;
    }

    // --- STATE ---
    let ghost, gears, particles;
    let score, gearsCleared, multiplier;
    let nextPhaseColor;
    let phaseShiftWarning, phaseShiftTimer;
    let gamePhase; // 'start', 'playing', 'tutorial', 'dead', 'over'
    let deadTimer, gameTime;
    let cameraY;
    let screenShake;
    let invertFlash, borderPulse;

    // --- TUTORIAL STATE ---
    let tutorialStep, tutorialPhase, tutorialTimer, tutorialGearsCleared;

    const TUTORIAL_STEPS = [
      {
        name: 'FLOAT',
        instruction: 'TAP TO FLOAT UP',
        setup() {
          gears = [];
          particles = [];
          gearsCleared = 0; score = 0; multiplier = 1; cameraY = 0;
          currentPhaseColor = T.cyan;
          nextPhaseColor = null;
          phaseShiftWarning = 0; phaseShiftTimer = 0;
          invertFlash = 0; borderPulse = 0;
          tutorialGearsCleared = 0;
          ghost = { x: W / 2, y: 150, vx: 0, vy: 0, r: 10, trail: [] };
          // one easy gear — all segments matching, slow rotation
          const g = createGear(0, T.cyan);
          g.segments = [T.cyan, T.cyan, T.cyan, T.cyan]; // all matching — can't fail
          g.speed = 0.3;
          gears.push(g);
        },
        check() { return tutorialGearsCleared >= 1; },
        successText: 'NICE!',
      },
      {
        name: 'COLOR',
        instruction: 'MATCH YOUR COLOR',
        setup() {
          gears = [];
          particles = [];
          gearsCleared = 0; score = 0; cameraY = 0;
          tutorialGearsCleared = 0;
          ghost = { x: W / 2, y: 150, vx: 0, vy: 0, r: 10, trail: [] };
          // 2 gears with mixed segments — must time to hit cyan
          for (let i = 0; i < 2; i++) {
            const g = createGear(i, T.cyan);
            g.speed = 0.5 * (i % 2 === 0 ? 1 : -1);
            gears.push(g);
          }
        },
        check() { return tutorialGearsCleared >= 2; },
        successText: 'PHASED!',
      },
      {
        name: 'SHIFT',
        instruction: 'YOUR COLOR WILL CHANGE',
        setup() {
          gears = [];
          particles = [];
          gearsCleared = 0; score = 0; cameraY = 0;
          tutorialGearsCleared = 0;
          currentPhaseColor = T.cyan;
          ghost = { x: W / 2, y: 150, vx: 0, vy: 0, r: 10, trail: [] };
          // 1 cyan gear, then trigger phase shift to fuchsia, then 1 fuchsia gear
          const g1 = createGear(0, T.cyan);
          g1.speed = 0.4;
          gears.push(g1);
          // second gear will be regenerated after shift
          const g2 = createGear(1, T.fuchsia);
          g2.speed = -0.4;
          gears.push(g2);
        },
        check() { return tutorialGearsCleared >= 2; },
        successText: 'READY!',
      },
    ];

    function init() {
      ghost = { x: W / 2, y: 150, vx: 0, vy: 0, r: 10, trail: [] };
      gears = [];
      particles = [];
      score = 0;
      gearsCleared = 0;
      multiplier = 1;
      currentPhaseColor = PHASE_COLORS[0];
      nextPhaseColor = null;
      phaseShiftWarning = 0;
      phaseShiftTimer = 0;
      gamePhase = 'start';
      deadTimer = 0;
      gameTime = 0;
      cameraY = 0;
      screenShake = { timer: 0, intensity: 0 };
      invertFlash = 0;
      borderPulse = 0;
      tutorialStep = -1;
      tutorialPhase = 'instruction';
      tutorialTimer = 0;
      tutorialGearsCleared = 0;
      stopTick();
      for (let i = 0; i < 20; i++) gears.push(createGear(i));
    }

    function startGame() {
      init();
      initAudio();
      gamePhase = 'playing';
      ghost.y = 150;
      ghost.vy = 0;
      startTick(60);
    }

    function startTutorial() {
      gamePhase = 'tutorial';
      tutorialStep = 0;
      tutorialPhase = 'instruction';
      tutorialTimer = 0;
      initAudio();
      TUTORIAL_STEPS[0].setup();
    }

    function skipTutorial() {
      tutorialStep = -1;
      stopTick();
      init();
      startGame();
    }

    function advanceTutorial() {
      tutorialStep++;
      if (tutorialStep >= TUTORIAL_STEPS.length) {
        tutorialStep = -1;
        stopTick();
        init();
        startGame();
        return;
      }
      tutorialPhase = 'instruction';
      tutorialTimer = 0;
      TUTORIAL_STEPS[tutorialStep].setup();
    }

    // --- COLLISION ---
    function checkGearCollision(gear) {
      const gy = getGearWorldY(gear);
      const ghostTop = ghost.y - ghost.r;
      const ghostBot = ghost.y + ghost.r;
      const bandTop = gy - GEAR_OUTER_R;
      const bandBot = gy + GEAR_OUTER_R;
      if (ghostBot < bandTop || ghostTop > bandBot) return 'none';
      const dx = ghost.x - gear.x;
      const dy = ghost.y - gy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < GEAR_INNER_R - ghost.r) return 'none';
      if (dist > GEAR_OUTER_R + ghost.r) return 'none';
      let angle = Math.atan2(dy, dx) - gear.angle;
      angle = ((angle % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
      const segAngle = (Math.PI * 2) / gear.numSegments;
      const segIdx = Math.floor(angle / segAngle);
      const segColor = gear.segments[segIdx];
      return segColor === currentPhaseColor ? 'phase' : 'hit';
    }

    // --- PARTICLES ---
    function spawnParticles(x, y, color, count) {
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 40 + Math.random() * 80;
        const life = 0.2 + Math.random() * 0.3;
        particles.push({ x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, r: 1.5 + Math.random() * 2.5, color, life, maxLife: life });
      }
    }

    // --- COLOR LERP ---
    function hexToRgb(hex) {
      return [parseInt(hex.slice(1,3),16), parseInt(hex.slice(3,5),16), parseInt(hex.slice(5,7),16)];
    }
    function lerpColor(c1, c2, t) {
      const [r1,g1,b1] = hexToRgb(c1);
      const [r2,g2,b2] = hexToRgb(c2);
      return `rgb(${Math.round(r1+(r2-r1)*t)},${Math.round(g1+(g2-g1)*t)},${Math.round(b1+(b2-b1)*t)})`;
    }

    // --- INPUT ---
    function handleStartClick(clientX, clientY) {
      const btnY = H / 2 + 115;
      if (Math.abs(clientY - btnY) < 20 && Math.abs(clientX - W / 2) < 80) {
        startTutorial();
        return;
      }
      startGame();
    }

    function handleTutorialClick(clientX, clientY) {
      if (clientX > W - 80 && clientY < 45) { skipTutorial(); return; }
    }

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const t = e.touches[0];
      if (gamePhase === 'start') { handleStartClick(t.clientX, t.clientY); return; }
      if (gamePhase === 'over') { init(); return; }
      if (gamePhase === 'tutorial') {
        handleTutorialClick(t.clientX, t.clientY);
        if (tutorialPhase === 'playing') {
          ghost.vy = TAP_IMPULSE;
          ghost.vx = (t.clientX - ghost.x) * 0.8;
          playTap();
        }
        return;
      }
      if (gamePhase === 'playing') {
        ghost.vy = TAP_IMPULSE;
        ghost.vx = (t.clientX - ghost.x) * 0.8;
        playTap();
      }
    });
    canvas.addEventListener('click', (e) => {
      if (gamePhase === 'start') { handleStartClick(e.clientX, e.clientY); return; }
      if (gamePhase === 'over') { init(); return; }
      if (gamePhase === 'tutorial') {
        handleTutorialClick(e.clientX, e.clientY);
        if (tutorialPhase === 'playing') {
          ghost.vy = TAP_IMPULSE;
          ghost.vx = (e.clientX - ghost.x) * 0.8;
          playTap();
        }
        return;
      }
      if (gamePhase === 'playing') {
        ghost.vy = TAP_IMPULSE;
        ghost.vx = (e.clientX - ghost.x) * 0.8;
        playTap();
      }
    });

    // --- UPDATE ---
    function die() {
      gamePhase = 'dead';
      deadTimer = 0;
      playClank();
      screenShake = { timer: 0.2, intensity: 4 };
      stopTick();
      spawnParticles(ghost.x, ghost.y, currentPhaseColor, 12);
    }

    function updateGhostPhysics(dt, gravityMod) {
      const grav = gravityMod || (GRAVITY + Math.min(gearsCleared * 3, 200));
      ghost.vy += grav * dt;
      if (ghost.vy > TERMINAL_VEL) ghost.vy = TERMINAL_VEL;
      ghost.y += ghost.vy * dt;
      ghost.x += ghost.vx * dt;
      ghost.vx *= 0.95;
      ghost.x = Math.max(ghost.r, Math.min(W - ghost.r, ghost.x));
      // trail (fix: store x position per point)
      ghost.trail.push({ x: ghost.x, y: ghost.y, life: 0.3 });
      if (ghost.trail.length > 15) ghost.trail.shift();
      for (const t of ghost.trail) t.life -= dt;
    }

    function update(dt) {
      if (gamePhase === 'start') { gameTime += dt; return; }
      gameTime += dt;

      if (gamePhase === 'tutorial') { updateTutorial(dt); return; }

      if (gamePhase === 'dead') {
        deadTimer += dt;
        ghost.vy += 300 * dt;
        ghost.y += ghost.vy * dt;
        if (deadTimer >= 1.5) gamePhase = 'over';
        return;
      }

      if (gamePhase !== 'playing') return;

      updateGhostPhysics(dt);

      if (ghost.y < cameraY - 100) { die(); return; }

      for (const g of gears) g.angle += g.speed * dt;

      for (const gear of gears) {
        if (gear.passed) continue;
        const gy = getGearWorldY(gear);
        if (Math.abs(ghost.y - gy) > GEAR_OUTER_R + ghost.r) continue;
        const result = checkGearCollision(gear);
        if (result === 'phase') {
          gear.passed = true;
          gearsCleared++;
          score += multiplier;
          playPhaseThrough(currentPhaseColor);
          spawnParticles(ghost.x, ghost.y, currentPhaseColor, 8);
          if (gearsCleared > 0 && gearsCleared % 10 === 0 && phaseShiftWarning === 0 && !nextPhaseColor) {
            const available = PHASE_COLORS.filter(c => c !== currentPhaseColor);
            nextPhaseColor = available[Math.floor(Math.random() * available.length)];
            phaseShiftWarning = 1.5;
            phaseShiftTimer = 0;
          }
          const bpm = 60 + Math.min(gearsCleared * 2, 120);
          startTick(bpm);
        }
        if (result === 'hit') { die(); return; }
      }

      // phase shift
      if (phaseShiftWarning > 0) {
        phaseShiftWarning -= dt;
        phaseShiftTimer += dt;
        if (phaseShiftWarning <= 0) {
          currentPhaseColor = nextPhaseColor;
          nextPhaseColor = null;
          phaseShiftWarning = 0;
          phaseShiftTimer = 0;
          invertFlash = 0.05;
          multiplier++;
          playShift();
          for (const gear of gears) {
            if (!gear.passed) {
              const otherColors = PHASE_COLORS.filter(c => c !== currentPhaseColor);
              const matchCount = gear.index < 20 ? 2 : 1;
              const matchIndices = [];
              while (matchIndices.length < matchCount) {
                const idx = Math.floor(Math.random() * gear.numSegments);
                if (!matchIndices.includes(idx)) matchIndices.push(idx);
              }
              for (let i = 0; i < gear.numSegments; i++) {
                gear.segments[i] = matchIndices.includes(i) ? currentPhaseColor : otherColors[Math.floor(Math.random() * otherColors.length)];
              }
            }
          }
        }
      }

      borderPulse = (phaseShiftWarning > 0 && phaseShiftWarning <= 0.5) ? Math.sin(gameTime * 12) * 0.5 + 0.5 : 0;

      const targetCam = ghost.y - H * 0.35;
      cameraY += (targetCam - cameraY) * 3 * dt;

      const lastGear = gears[gears.length - 1];
      if (lastGear && getGearWorldY(lastGear) - cameraY < H + 200) gears.push(createGear(lastGear.index + 1));
      while (gears.length > 0 && getGearWorldY(gears[0]) < cameraY - 200) gears.shift();

      if (screenShake.timer > 0) screenShake.timer -= dt;
      if (invertFlash > 0) invertFlash -= dt;

      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx * dt; p.y += p.vy * dt;
        p.life -= dt;
        if (p.life <= 0) particles.splice(i, 1);
      }
    }

    // --- TUTORIAL UPDATE ---
    function updateTutorial(dt) {
      if (tutorialStep < 0 || tutorialStep >= TUTORIAL_STEPS.length) return;
      const step = TUTORIAL_STEPS[tutorialStep];

      if (tutorialPhase === 'instruction') {
        tutorialTimer += dt;
        if (tutorialTimer >= 1.2) { tutorialPhase = 'playing'; tutorialTimer = 0; }
        return;
      }

      if (tutorialPhase === 'playing') {
        updateGhostPhysics(dt, 300); // slower gravity for tutorial

        for (const g of gears) g.angle += g.speed * dt;

        // trigger phase shift in step 3 after first gear cleared
        if (tutorialStep === 2 && tutorialGearsCleared === 1 && phaseShiftWarning === 0 && !nextPhaseColor) {
          nextPhaseColor = T.fuchsia;
          phaseShiftWarning = 1.5;
          phaseShiftTimer = 0;
        }

        // phase shift countdown
        if (phaseShiftWarning > 0) {
          phaseShiftWarning -= dt;
          phaseShiftTimer += dt;
          if (phaseShiftWarning <= 0) {
            currentPhaseColor = nextPhaseColor;
            nextPhaseColor = null;
            phaseShiftWarning = 0;
            phaseShiftTimer = 0;
            invertFlash = 0.05;
            playShift();
            for (const gear of gears) {
              if (!gear.passed) {
                const otherColors = PHASE_COLORS.filter(c => c !== currentPhaseColor);
                const matchIndices = [0, 1]; // generous in tutorial
                for (let i = 0; i < gear.numSegments; i++) {
                  gear.segments[i] = matchIndices.includes(i) ? currentPhaseColor : otherColors[Math.floor(Math.random() * otherColors.length)];
                }
              }
            }
          }
        }

        borderPulse = (phaseShiftWarning > 0 && phaseShiftWarning <= 0.5) ? Math.sin(gameTime * 12) * 0.5 + 0.5 : 0;

        for (const gear of gears) {
          if (gear.passed) continue;
          const gy = getGearWorldY(gear);
          if (Math.abs(ghost.y - gy) > GEAR_OUTER_R + ghost.r) continue;
          const result = checkGearCollision(gear);
          if (result === 'phase') {
            gear.passed = true;
            tutorialGearsCleared++;
            playPhaseThrough(currentPhaseColor);
            spawnParticles(ghost.x, ghost.y, currentPhaseColor, 8);
          }
          if (result === 'hit') {
            // tutorial: bounce off, don't kill
            ghost.vy = TAP_IMPULSE * 0.5;
            screenShake = { timer: 0.1, intensity: 2 };
            playClank();
            break;
          }
        }

        const targetCam = ghost.y - H * 0.35;
        cameraY += (targetCam - cameraY) * 3 * dt;

        if (screenShake.timer > 0) screenShake.timer -= dt;
        if (invertFlash > 0) invertFlash -= dt;

        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.x += p.vx * dt; p.y += p.vy * dt;
          p.life -= dt;
          if (p.life <= 0) particles.splice(i, 1);
        }

        if (step.check()) {
          tutorialPhase = 'success';
          tutorialTimer = 0;
          playLevelUp();
        }
        return;
      }

      if (tutorialPhase === 'success') {
        tutorialTimer += dt;
        const delay = tutorialStep === TUTORIAL_STEPS.length - 1 ? 1.0 : 0.6;
        if (tutorialTimer >= delay) advanceTutorial();
      }
    }

    // --- DRAW HELPERS ---
    function drawGearsAndGhost() {
      // gears
      for (const gear of gears) {
        const gy = getGearWorldY(gear) - cameraY;
        if (gy < -80 || gy > H + 80) continue;
        const segAngle = (Math.PI * 2) / gear.numSegments;
        for (let i = 0; i < gear.numSegments; i++) {
          const startA = gear.angle + i * segAngle;
          const endA = startA + segAngle;
          ctx.fillStyle = gear.passed ? T.grey : gear.segments[i];
          ctx.globalAlpha = gear.passed ? 0.15 : 0.8;
          ctx.beginPath();
          ctx.arc(gear.x, gy, GEAR_OUTER_R, startA, endA);
          ctx.arc(gear.x, gy, GEAR_INNER_R, endA, startA, true);
          ctx.closePath();
          ctx.fill();
          if (!gear.passed && gear.segments[i] === currentPhaseColor) {
            ctx.shadowBlur = 8;
            ctx.shadowColor = gear.segments[i];
            ctx.fill();
            ctx.shadowBlur = 0;
          }
        }
        ctx.globalAlpha = gear.passed ? 0.1 : 0.3;
        ctx.fillStyle = T.gear;
        ctx.beginPath();
        ctx.arc(gear.x, gy, GEAR_INNER_R, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }

      // particles
      for (const p of particles) {
        const py = p.y - cameraY;
        ctx.globalAlpha = p.life / p.maxLife;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, py, p.r * (p.life / p.maxLife), 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      // ghost trail (using stored x)
      for (const t of ghost.trail) {
        if (t.life <= 0) continue;
        const ty = t.y - cameraY;
        ctx.globalAlpha = t.life / 0.3 * 0.3;
        ctx.fillStyle = currentPhaseColor;
        ctx.beginPath();
        ctx.arc(t.x, ty, ghost.r * 0.6, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      // ghost
      if (gamePhase === 'playing' || gamePhase === 'tutorial' || gamePhase === 'dead') {
        const gy = ghost.y - cameraY;
        let auraColor = currentPhaseColor;
        if (phaseShiftWarning > 0 && nextPhaseColor) {
          const t = Math.sin(phaseShiftTimer * 8) * 0.5 + 0.5;
          auraColor = lerpColor(currentPhaseColor, nextPhaseColor, t);
        }
        ctx.shadowBlur = 16;
        ctx.shadowColor = auraColor;
        ctx.fillStyle = auraColor;
        ctx.globalAlpha = 0.4;
        ctx.beginPath();
        ctx.arc(ghost.x, gy, ghost.r + 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
        ctx.shadowColor = T.text;
        ctx.fillStyle = T.text;
        ctx.beginPath();
        ctx.arc(ghost.x, gy, ghost.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.fillStyle = auraColor;
        ctx.beginPath();
        ctx.arc(ghost.x, gy, ghost.r * 0.4, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // --- DRAW ---
    function draw() {
      if (invertFlash > 0) { ctx.fillStyle = T.text; ctx.fillRect(0, 0, W, H); return; }

      ctx.fillStyle = T.bg;
      ctx.fillRect(0, 0, W, H);

      if (gamePhase === 'start') { drawStart(); return; }
      if (gamePhase === 'tutorial') { drawTutorial(); return; }
      if (gamePhase === 'over') { drawGameOver(); return; }

      // bg lines
      ctx.strokeStyle = '#141414';
      ctx.lineWidth = 1;
      for (let x = W * 0.15; x <= W * 0.85; x += W * 0.35) {
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
      }

      ctx.save();
      if (screenShake.timer > 0) {
        const s = screenShake.intensity * (screenShake.timer / 0.2);
        ctx.translate((Math.random() * 2 - 1) * s, (Math.random() * 2 - 1) * s);
      }

      drawGearsAndGhost();
      ctx.restore();

      // HUD
      ctx.fillStyle = T.text;
      ctx.font = 'bold 28px monospace';
      ctx.textAlign = 'left';
      ctx.fillText(score + '', 16, 40);
      ctx.font = '14px monospace';
      ctx.fillStyle = T.grey;
      ctx.fillText('gear ' + gearsCleared, 16, 60);
      if (multiplier > 1) {
        ctx.fillStyle = currentPhaseColor;
        ctx.font = 'bold 18px monospace';
        ctx.textAlign = 'right';
        ctx.fillText(multiplier + 'x', W - 16, 40);
      }
      if (borderPulse > 0 && nextPhaseColor) {
        ctx.strokeStyle = nextPhaseColor;
        ctx.lineWidth = 3;
        ctx.globalAlpha = borderPulse * 0.6;
        ctx.strokeRect(2, 2, W - 4, H - 4);
        ctx.globalAlpha = 1;
      }
      if (phaseShiftWarning > 0 && nextPhaseColor) {
        ctx.fillStyle = nextPhaseColor;
        ctx.globalAlpha = 0.3 + Math.sin(gameTime * 6) * 0.15;
        ctx.font = '12px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('PHASE SHIFT', W / 2, 30);
        ctx.globalAlpha = 1;
      }
      if (gamePhase === 'dead') {
        const t = Math.min(deadTimer / 1.0, 1);
        ctx.fillStyle = `rgba(0,0,0,${t * 0.6})`;
        ctx.fillRect(0, 0, W, H);
        ctx.fillStyle = T.text;
        ctx.font = 'bold 32px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('CLANK', W / 2, H / 2 - 10);
      }
      ctx.textAlign = 'left';
    }

    // --- TUTORIAL DRAW ---
    function drawTutorial() {
      if (tutorialStep < 0 || tutorialStep >= TUTORIAL_STEPS.length) return;
      const step = TUTORIAL_STEPS[tutorialStep];

      ctx.fillStyle = T.bg;
      ctx.fillRect(0, 0, W, H);

      ctx.save();
      if (screenShake.timer > 0) {
        const s = screenShake.intensity * (screenShake.timer / 0.2);
        ctx.translate((Math.random() * 2 - 1) * s, (Math.random() * 2 - 1) * s);
      }
      drawGearsAndGhost();
      ctx.restore();

      // border pulse during tutorial phase shift
      if (borderPulse > 0 && nextPhaseColor) {
        ctx.strokeStyle = nextPhaseColor;
        ctx.lineWidth = 3;
        ctx.globalAlpha = borderPulse * 0.6;
        ctx.strokeRect(2, 2, W - 4, H - 4);
        ctx.globalAlpha = 1;
      }
      if (phaseShiftWarning > 0 && nextPhaseColor) {
        ctx.fillStyle = nextPhaseColor;
        ctx.globalAlpha = 0.3 + Math.sin(gameTime * 6) * 0.15;
        ctx.font = '12px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('PHASE SHIFT', W / 2, 80);
        ctx.globalAlpha = 1;
      }

      // step counter
      ctx.fillStyle = 'rgba(255,255,255,0.4)';
      ctx.font = '14px monospace';
      ctx.textAlign = 'left';
      ctx.fillText((tutorialStep + 1) + '/' + TUTORIAL_STEPS.length, 16, 30);

      // instruction
      if (tutorialPhase === 'instruction' || tutorialPhase === 'playing') {
        ctx.fillStyle = T.text;
        ctx.font = 'bold 22px monospace';
        ctx.textAlign = 'center';
        ctx.fillText(step.instruction, W / 2, 50);
      }

      // success
      if (tutorialPhase === 'success') {
        ctx.fillStyle = T.slime;
        ctx.font = 'bold 36px monospace';
        ctx.textAlign = 'center';
        ctx.shadowBlur = 12;
        ctx.shadowColor = T.slime;
        ctx.fillText(step.successText, W / 2, H / 2 - 20);
        ctx.shadowBlur = 0;
      }

      // SKIP
      ctx.fillStyle = 'rgba(255,255,255,0.3)';
      ctx.font = '14px monospace';
      ctx.textAlign = 'right';
      ctx.fillText('SKIP >', W - 16, 30);
      ctx.textAlign = 'left';
    }

    function drawStart() {
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(0, 0, W, H);
      ctx.textAlign = 'center';

      const bobY = Math.sin(gameTime * 2) * 8;
      ctx.shadowBlur = 16;
      ctx.shadowColor = T.cyan;
      ctx.fillStyle = T.cyan;
      ctx.globalAlpha = 0.4;
      ctx.beginPath();
      ctx.arc(W / 2, H / 2 - 75 + bobY, 16, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.shadowColor = T.text;
      ctx.fillStyle = T.text;
      ctx.beginPath();
      ctx.arc(W / 2, H / 2 - 75 + bobY, 10, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.fillStyle = T.cyan;
      ctx.beginPath();
      ctx.arc(W / 2, H / 2 - 75 + bobY, 4, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = T.cyan;
      ctx.font = 'bold 48px monospace';
      ctx.shadowBlur = 16;
      ctx.shadowColor = T.cyan;
      ctx.fillText('PHASE', W / 2, H / 2 - 20);
      ctx.shadowBlur = 0;

      ctx.fillStyle = T.text;
      ctx.font = '16px monospace';
      ctx.fillText('Tap to float through matching gears', W / 2, H / 2 + 10);
      ctx.fillText('Match your color to pass through', W / 2, H / 2 + 33);

      ctx.fillStyle = T.cyan;
      ctx.font = '20px monospace';
      ctx.fillText('[ TAP TO START ]', W / 2, H / 2 + 80);

      ctx.fillStyle = 'rgba(255,255,255,0.5)';
      ctx.font = '16px monospace';
      ctx.fillText('[ TUTORIAL ]', W / 2, H / 2 + 115);

      ctx.textAlign = 'left';
    }

    function drawGameOver() {
      ctx.fillStyle = 'rgba(0,0,0,0.85)';
      ctx.fillRect(0, 0, W, H);
      ctx.textAlign = 'center';

      ctx.fillStyle = T.gold;
      ctx.font = 'bold 56px monospace';
      ctx.shadowBlur = 12;
      ctx.shadowColor = T.gold;
      ctx.fillText(score + '', W / 2, H / 2 - 40);
      ctx.shadowBlur = 0;

      ctx.fillStyle = T.text;
      ctx.font = '16px monospace';
      ctx.fillText('gears: ' + gearsCleared + '  |  ' + multiplier + 'x multiplier', W / 2, H / 2);

      ctx.fillStyle = T.cyan;
      ctx.font = '20px monospace';
      ctx.fillText('[ TAP TO RETRY ]', W / 2, H / 2 + 50);

      ctx.textAlign = 'left';
    }

    // --- LOOP ---
    let lastTime = performance.now();
    init();

    function loop(ts) {
      const dt = Math.min((ts - lastTime) / 1000, 0.05);
      lastTime = ts;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
  </script>
</body>
</html>
