<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>PHASE</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #0a0a0a;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      overflow: hidden;
      touch-action: none;
      font-family: monospace;
    }
    canvas { display: block; }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // --- THEME ---
    const T = {
      bg: '#0a0a0a',
      gear: '#2a2a2e',
      cyan: '#22d3ee',
      fuchsia: '#d946ef',
      gold: '#facc15',
      text: '#ffffff',
      grey: '#555555',
    };

    const PHASE_COLORS = [T.cyan, T.fuchsia, T.gold];

    let W, H;
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      W = canvas.width;
      H = canvas.height;
    }
    resize();
    window.addEventListener('resize', resize);

    // --- AUDIO ---
    let audioCtx;
    function initAudio() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === 'suspended') audioCtx.resume();
    }
    canvas.addEventListener('touchstart', initAudio, { once: true });
    canvas.addEventListener('click', initAudio, { once: true });

    // chime per color: cyan=high, fuchsia=mid, gold=low
    const CHIME_FREQ = { [T.cyan]: 880, [T.fuchsia]: 587, [T.gold]: 392 };

    function playPhaseThrough(color) {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.connect(g); g.connect(audioCtx.destination);
      osc.type = 'sine';
      osc.frequency.value = CHIME_FREQ[color] || 660;
      g.gain.setValueAtTime(0.1, audioCtx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.25);
      osc.start(); osc.stop(audioCtx.currentTime + 0.25);
    }

    function playClank() {
      if (!audioCtx) return;
      // metallic clank
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.connect(g); g.connect(audioCtx.destination);
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(300, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(80, audioCtx.currentTime + 0.15);
      g.gain.setValueAtTime(0.2, audioCtx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);
      osc.start(); osc.stop(audioCtx.currentTime + 0.2);
      // noise layer
      const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.1, audioCtx.sampleRate);
      const data = buf.getChannelData(0);
      for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * (1 - i / data.length);
      const src = audioCtx.createBufferSource();
      const ng = audioCtx.createGain();
      src.buffer = buf; src.connect(ng); ng.connect(audioCtx.destination);
      ng.gain.setValueAtTime(0.12, audioCtx.currentTime);
      ng.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
      src.start();
    }

    function playShift() {
      if (!audioCtx) return;
      // ascending chromatic sweep
      for (let i = 0; i < 4; i++) {
        setTimeout(() => {
          if (!audioCtx) return;
          const osc = audioCtx.createOscillator();
          const g = audioCtx.createGain();
          osc.connect(g); g.connect(audioCtx.destination);
          osc.type = 'triangle';
          osc.frequency.value = 400 + i * 150;
          g.gain.setValueAtTime(0.08, audioCtx.currentTime);
          g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.12);
          osc.start(); osc.stop(audioCtx.currentTime + 0.12);
        }, i * 60);
      }
    }

    function playTap() {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.connect(g); g.connect(audioCtx.destination);
      osc.type = 'sine';
      osc.frequency.value = 440;
      g.gain.setValueAtTime(0.05, audioCtx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.06);
      osc.start(); osc.stop(audioCtx.currentTime + 0.06);
    }

    // --- CLOCK TICK ---
    let tickInterval;
    function startTick(bpm) {
      stopTick();
      const ms = 60000 / bpm;
      tickInterval = setInterval(() => {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        osc.connect(g); g.connect(audioCtx.destination);
        osc.type = 'square';
        osc.frequency.value = 1200;
        g.gain.setValueAtTime(0.02, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.02);
        osc.start(); osc.stop(audioCtx.currentTime + 0.02);
      }, ms);
    }
    function stopTick() {
      if (tickInterval) { clearInterval(tickInterval); tickInterval = null; }
    }

    // --- GEAR GENERATION ---
    const GEAR_SPACING = 140;
    const GEAR_OUTER_R = 55;
    const GEAR_INNER_R = 20;

    function createGear(index) {
      const numSegments = 4;
      // difficulty ramp: 2 matching early, 1 matching later
      const matchCount = index < 20 ? 2 : 1;

      // assign colors to segments
      const segments = [];
      const otherColors = PHASE_COLORS.filter(c => c !== currentPhaseColor);

      // place matching segments randomly
      const matchIndices = [];
      while (matchIndices.length < matchCount) {
        const idx = Math.floor(Math.random() * numSegments);
        if (!matchIndices.includes(idx)) matchIndices.push(idx);
      }

      for (let i = 0; i < numSegments; i++) {
        if (matchIndices.includes(i)) {
          segments.push(currentPhaseColor);
        } else {
          segments.push(otherColors[Math.floor(Math.random() * otherColors.length)]);
        }
      }

      // rotation speed increases with depth
      const baseSpeed = 0.8 + Math.min(index * 0.04, 1.5);
      const dir = Math.random() < 0.5 ? 1 : -1;

      return {
        index,
        x: W / 2,
        y: 0, // positioned relative to camera
        angle: Math.random() * Math.PI * 2,
        speed: baseSpeed * dir,
        segments,
        numSegments,
        passed: false,
      };
    }

    function getGearWorldY(gear) {
      return 250 + gear.index * GEAR_SPACING;
    }

    // --- STATE ---
    let ghost, gears, particles;
    let score, gearsCleared, multiplier;
    let currentPhaseColor, nextPhaseColor;
    let phaseShiftWarning; // seconds until shift (0 = no warning)
    let phaseShiftTimer;
    let gamePhase; // 'start', 'playing', 'dead', 'over'
    let deadTimer, gameTime;
    let cameraY;
    let screenShake;
    let invertFlash;
    let borderPulse;

    function init() {
      ghost = {
        x: W / 2,
        y: 150,
        vx: 0,
        vy: 0,
        r: 10,
        trail: [],
      };
      gears = [];
      particles = [];
      score = 0;
      gearsCleared = 0;
      multiplier = 1;
      currentPhaseColor = PHASE_COLORS[0];
      nextPhaseColor = null;
      phaseShiftWarning = 0;
      phaseShiftTimer = 0;
      gamePhase = 'start';
      deadTimer = 0;
      gameTime = 0;
      cameraY = 0;
      screenShake = { timer: 0, intensity: 0 };
      invertFlash = 0;
      borderPulse = 0;
      stopTick();

      for (let i = 0; i < 20; i++) {
        gears.push(createGear(i));
      }
    }

    // --- PHYSICS ---
    const GRAVITY = 400;
    const TAP_IMPULSE = -220;
    const TERMINAL_VEL = 350;

    // --- INPUT ---
    function handleTap(clientX) {
      if (gamePhase === 'start') { startGame(); return; }
      if (gamePhase === 'over') { init(); return; }
      if (gamePhase === 'playing') {
        ghost.vy = TAP_IMPULSE;
        // horizontal drift toward tap position
        const tapX = clientX !== undefined ? clientX : W / 2;
        ghost.vx = (tapX - ghost.x) * 0.8;
        playTap();
      }
    }
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      handleTap(e.touches[0].clientX);
    });
    canvas.addEventListener('click', (e) => {
      handleTap(e.clientX);
    });

    function startGame() {
      init();
      initAudio();
      gamePhase = 'playing';
      ghost.y = 150;
      ghost.vy = 0;
      startTick(60);
    }

    // --- COLLISION ---
    // Crossing-based: check when ghost Y passes through the gear's Y band
    function checkGearCollision(gear) {
      const gy = getGearWorldY(gear);
      const ghostTop = ghost.y - ghost.r;
      const ghostBot = ghost.y + ghost.r;
      const bandTop = gy - GEAR_OUTER_R;
      const bandBot = gy + GEAR_OUTER_R;

      // ghost must overlap gear's vertical band
      if (ghostBot < bandTop || ghostTop > bandBot) return 'none';

      // check horizontal distance to gear center
      const dx = ghost.x - gear.x;
      const dy = ghost.y - gy;
      const dist = Math.sqrt(dx * dx + dy * dy);

      // inside the inner hole — free pass (no ring here)
      if (dist < GEAR_INNER_R - ghost.r) return 'none';

      // outside the outer ring — no contact
      if (dist > GEAR_OUTER_R + ghost.r) return 'none';

      // in the ring zone — determine which segment
      let angle = Math.atan2(dy, dx) - gear.angle;
      angle = ((angle % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
      const segAngle = (Math.PI * 2) / gear.numSegments;
      const segIdx = Math.floor(angle / segAngle);
      const segColor = gear.segments[segIdx];

      if (segColor === currentPhaseColor) {
        return 'phase';
      } else {
        return 'hit';
      }
    }

    // --- UPDATE ---
    function update(dt) {
      if (gamePhase === 'start') { gameTime += dt; return; }
      gameTime += dt;

      if (gamePhase === 'dead') {
        deadTimer += dt;
        ghost.vy += 300 * dt;
        ghost.y += ghost.vy * dt;
        if (deadTimer >= 1.5) gamePhase = 'over';
        return;
      }

      if (gamePhase !== 'playing') return;

      // Ghost physics
      ghost.vy += GRAVITY * dt;
      if (ghost.vy > TERMINAL_VEL) ghost.vy = TERMINAL_VEL;
      ghost.y += ghost.vy * dt;
      // horizontal drift with damping
      ghost.x += ghost.vx * dt;
      ghost.vx *= 0.95; // friction
      // clamp to screen
      ghost.x = Math.max(ghost.r, Math.min(W - ghost.r, ghost.x));

      // Trail
      ghost.trail.push({ x: ghost.x, y: ghost.y, life: 0.3 });
      if (ghost.trail.length > 15) ghost.trail.shift();
      for (const t of ghost.trail) t.life -= dt;

      // Death if fall off screen top
      if (ghost.y < cameraY - 100) {
        die();
        return;
      }

      // Rotate gears
      for (const g of gears) {
        g.angle += g.speed * dt;
      }

      // Check gear collisions
      for (const gear of gears) {
        if (gear.passed) continue;
        const gy = getGearWorldY(gear);

        // only check when ghost is near the gear vertically
        if (Math.abs(ghost.y - gy) > GEAR_OUTER_R + ghost.r) continue;

        const result = checkGearCollision(gear);

        if (result === 'phase') {
          // pass through!
          gear.passed = true;
          gearsCleared++;
          score += multiplier;
          playPhaseThrough(currentPhaseColor);
          spawnParticles(ghost.x, ghost.y, currentPhaseColor, 8);

          // phase shift check — trigger between gears
          if (gearsCleared > 0 && gearsCleared % 10 === 0 && phaseShiftWarning === 0 && !nextPhaseColor) {
            // start warning
            const available = PHASE_COLORS.filter(c => c !== currentPhaseColor);
            nextPhaseColor = available[Math.floor(Math.random() * available.length)];
            phaseShiftWarning = 1.5;
            phaseShiftTimer = 0;
          }

          // update tick speed
          const bpm = 60 + Math.min(gearsCleared * 2, 120);
          startTick(bpm);
        }

        if (result === 'hit') {
          die();
          return;
        }
      }

      // Phase shift warning countdown
      if (phaseShiftWarning > 0) {
        phaseShiftWarning -= dt;
        phaseShiftTimer += dt;

        if (phaseShiftWarning <= 0) {
          // SHIFT!
          currentPhaseColor = nextPhaseColor;
          nextPhaseColor = null;
          phaseShiftWarning = 0;
          phaseShiftTimer = 0;
          invertFlash = 0.05; // 1 frame at 60fps
          multiplier++;
          playShift();

          // regenerate ALL upcoming gear colors for new phase (including next gear)
          for (const gear of gears) {
            if (!gear.passed) {
              const otherColors = PHASE_COLORS.filter(c => c !== currentPhaseColor);
              const matchCount = gear.index < 20 ? 2 : 1;
              const matchIndices = [];
              while (matchIndices.length < matchCount) {
                const idx = Math.floor(Math.random() * gear.numSegments);
                if (!matchIndices.includes(idx)) matchIndices.push(idx);
              }
              for (let i = 0; i < gear.numSegments; i++) {
                gear.segments[i] = matchIndices.includes(i)
                  ? currentPhaseColor
                  : otherColors[Math.floor(Math.random() * otherColors.length)];
              }
            }
          }
        }
      }

      // Border pulse (last 0.5s of warning)
      if (phaseShiftWarning > 0 && phaseShiftWarning <= 0.5) {
        borderPulse = Math.sin(gameTime * 12) * 0.5 + 0.5;
      } else {
        borderPulse = 0;
      }

      // Camera
      const targetCam = ghost.y - H * 0.35;
      cameraY += (targetCam - cameraY) * 3 * dt;

      // Generate more gears
      const lastGear = gears[gears.length - 1];
      if (lastGear && getGearWorldY(lastGear) - cameraY < H + 200) {
        gears.push(createGear(lastGear.index + 1));
      }

      // Remove old gears
      while (gears.length > 0 && getGearWorldY(gears[0]) < cameraY - 200) {
        gears.shift();
      }

      // Screen shake
      if (screenShake.timer > 0) screenShake.timer -= dt;
      if (invertFlash > 0) invertFlash -= dt;

      // Particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.life -= dt;
        if (p.life <= 0) particles.splice(i, 1);
      }
    }

    function die() {
      gamePhase = 'dead';
      deadTimer = 0;
      playClank();
      screenShake = { timer: 0.2, intensity: 4 };
      stopTick();
      spawnParticles(ghost.x, ghost.y, currentPhaseColor, 12);
    }

    function spawnParticles(x, y, color, count) {
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 40 + Math.random() * 80;
        const life = 0.2 + Math.random() * 0.3;
        particles.push({
          x, y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          r: 1.5 + Math.random() * 2.5,
          color, life, maxLife: life,
        });
      }
    }

    // --- COLOR LERP ---
    function hexToRgb(hex) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return [r, g, b];
    }

    function lerpColor(c1, c2, t) {
      const [r1, g1, b1] = hexToRgb(c1);
      const [r2, g2, b2] = hexToRgb(c2);
      const r = Math.round(r1 + (r2 - r1) * t);
      const g = Math.round(g1 + (g2 - g1) * t);
      const b = Math.round(b1 + (b2 - b1) * t);
      return `rgb(${r},${g},${b})`;
    }

    // --- DRAW ---
    function draw() {
      // invert flash
      if (invertFlash > 0) {
        ctx.fillStyle = T.text;
        ctx.fillRect(0, 0, W, H);
        return;
      }

      ctx.fillStyle = T.bg;
      ctx.fillRect(0, 0, W, H);

      if (gamePhase === 'start') { drawStart(); return; }
      if (gamePhase === 'over') { drawGameOver(); return; }

      // clock tower bg lines
      ctx.strokeStyle = '#141414';
      ctx.lineWidth = 1;
      for (let x = W * 0.15; x <= W * 0.85; x += W * 0.35) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, H);
        ctx.stroke();
      }

      ctx.save();
      if (screenShake.timer > 0) {
        const s = screenShake.intensity * (screenShake.timer / 0.2);
        ctx.translate((Math.random() * 2 - 1) * s, (Math.random() * 2 - 1) * s);
      }

      // Draw gears
      for (const gear of gears) {
        const gy = getGearWorldY(gear) - cameraY;
        if (gy < -80 || gy > H + 80) continue;

        const segAngle = (Math.PI * 2) / gear.numSegments;

        for (let i = 0; i < gear.numSegments; i++) {
          const startA = gear.angle + i * segAngle;
          const endA = startA + segAngle;

          ctx.fillStyle = gear.passed ? T.grey : gear.segments[i];
          ctx.globalAlpha = gear.passed ? 0.15 : 0.8;

          // draw arc segment
          ctx.beginPath();
          ctx.arc(gear.x, gy, GEAR_OUTER_R, startA, endA);
          ctx.arc(gear.x, gy, GEAR_INNER_R, endA, startA, true);
          ctx.closePath();
          ctx.fill();

          // segment glow
          if (!gear.passed && gear.segments[i] === currentPhaseColor) {
            ctx.shadowBlur = 8;
            ctx.shadowColor = gear.segments[i];
            ctx.fill();
            ctx.shadowBlur = 0;
          }
        }

        // gear center
        ctx.globalAlpha = gear.passed ? 0.1 : 0.3;
        ctx.fillStyle = T.gear;
        ctx.beginPath();
        ctx.arc(gear.x, gy, GEAR_INNER_R, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }

      // Particles
      for (const p of particles) {
        const py = p.y - cameraY;
        ctx.globalAlpha = p.life / p.maxLife;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, py, p.r * (p.life / p.maxLife), 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      // Ghost trail
      for (const t of ghost.trail) {
        if (t.life <= 0) continue;
        const ty = t.y - cameraY;
        ctx.globalAlpha = t.life / 0.3 * 0.3;
        ctx.fillStyle = currentPhaseColor;
        ctx.beginPath();
        ctx.arc(ghost.x, ty, ghost.r * 0.6, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      // Ghost
      if (gamePhase === 'playing' || gamePhase === 'dead') {
        const gy = ghost.y - cameraY;

        // aura color — flicker during warning
        let auraColor = currentPhaseColor;
        if (phaseShiftWarning > 0 && nextPhaseColor) {
          // smooth oscillation between current and next
          const t = Math.sin(phaseShiftTimer * 8) * 0.5 + 0.5;
          auraColor = lerpColor(currentPhaseColor, nextPhaseColor, t);
        }

        // aura glow
        ctx.shadowBlur = 16;
        ctx.shadowColor = auraColor;
        ctx.fillStyle = auraColor;
        ctx.globalAlpha = 0.4;
        ctx.beginPath();
        ctx.arc(ghost.x, gy, ghost.r + 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;

        // core
        ctx.shadowBlur = 8;
        ctx.shadowColor = T.text;
        ctx.fillStyle = T.text;
        ctx.beginPath();
        ctx.arc(ghost.x, gy, ghost.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // inner color dot
        ctx.fillStyle = auraColor;
        ctx.beginPath();
        ctx.arc(ghost.x, gy, ghost.r * 0.4, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.restore();

      // --- HUD ---
      ctx.fillStyle = T.text;
      ctx.font = 'bold 28px monospace';
      ctx.textAlign = 'left';
      ctx.fillText(score + '', 16, 40);

      ctx.font = '14px monospace';
      ctx.fillStyle = T.grey;
      ctx.fillText('gear ' + gearsCleared, 16, 60);

      // multiplier
      if (multiplier > 1) {
        ctx.fillStyle = currentPhaseColor;
        ctx.font = 'bold 18px monospace';
        ctx.textAlign = 'right';
        ctx.fillText(multiplier + 'x', W - 16, 40);
      }

      // phase shift border pulse
      if (borderPulse > 0 && nextPhaseColor) {
        ctx.strokeStyle = nextPhaseColor;
        ctx.lineWidth = 3;
        ctx.globalAlpha = borderPulse * 0.6;
        ctx.strokeRect(2, 2, W - 4, H - 4);
        ctx.globalAlpha = 1;
      }

      // phase shift flicker indicator
      if (phaseShiftWarning > 0.5 && nextPhaseColor) {
        ctx.fillStyle = nextPhaseColor;
        ctx.globalAlpha = 0.3 + Math.sin(gameTime * 6) * 0.15;
        ctx.font = '12px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('PHASE SHIFT', W / 2, 30);
        ctx.globalAlpha = 1;
      }

      // dead overlay
      if (gamePhase === 'dead') {
        const t = Math.min(deadTimer / 1.0, 1);
        ctx.fillStyle = `rgba(0,0,0,${t * 0.6})`;
        ctx.fillRect(0, 0, W, H);
        ctx.fillStyle = T.text;
        ctx.font = 'bold 32px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('CLANK', W / 2, H / 2 - 10);
      }

      ctx.textAlign = 'left';
    }

    function drawStart() {
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(0, 0, W, H);

      ctx.textAlign = 'center';

      // ghost preview
      const bobY = Math.sin(gameTime * 2) * 8;
      // aura
      ctx.shadowBlur = 16;
      ctx.shadowColor = T.cyan;
      ctx.fillStyle = T.cyan;
      ctx.globalAlpha = 0.4;
      ctx.beginPath();
      ctx.arc(W / 2, H / 2 - 75 + bobY, 16, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
      // core
      ctx.shadowColor = T.text;
      ctx.fillStyle = T.text;
      ctx.beginPath();
      ctx.arc(W / 2, H / 2 - 75 + bobY, 10, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.fillStyle = T.cyan;
      ctx.beginPath();
      ctx.arc(W / 2, H / 2 - 75 + bobY, 4, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = T.cyan;
      ctx.font = 'bold 48px monospace';
      ctx.shadowBlur = 16;
      ctx.shadowColor = T.cyan;
      ctx.fillText('PHASE', W / 2, H / 2 - 20);
      ctx.shadowBlur = 0;

      ctx.fillStyle = T.text;
      ctx.font = '16px monospace';
      ctx.fillText('Tap to float through matching gears', W / 2, H / 2 + 10);
      ctx.fillText('Match your color to pass through', W / 2, H / 2 + 33);

      ctx.fillStyle = T.cyan;
      ctx.font = '20px monospace';
      ctx.fillText('[ TAP TO START ]', W / 2, H / 2 + 80);

      ctx.textAlign = 'left';
    }

    function drawGameOver() {
      ctx.fillStyle = 'rgba(0,0,0,0.85)';
      ctx.fillRect(0, 0, W, H);

      ctx.textAlign = 'center';

      ctx.fillStyle = T.gold;
      ctx.font = 'bold 56px monospace';
      ctx.shadowBlur = 12;
      ctx.shadowColor = T.gold;
      ctx.fillText(score + '', W / 2, H / 2 - 40);
      ctx.shadowBlur = 0;

      ctx.fillStyle = T.text;
      ctx.font = '16px monospace';
      ctx.fillText('gears: ' + gearsCleared + '  |  ' + multiplier + 'x multiplier', W / 2, H / 2);

      ctx.fillStyle = T.cyan;
      ctx.font = '20px monospace';
      ctx.fillText('[ TAP TO RETRY ]', W / 2, H / 2 + 50);

      ctx.textAlign = 'left';
    }

    // --- LOOP ---
    let lastTime = performance.now();
    init();

    function loop(ts) {
      const dt = Math.min((ts - lastTime) / 1000, 0.05);
      lastTime = ts;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
  </script>
</body>
</html>
