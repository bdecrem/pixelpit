<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>FOLD</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #0a0a0a;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      overflow: hidden;
      touch-action: none;
      font-family: monospace;
    }
    canvas { display: block; }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // --- THEME (Indie Bite) ---
    const T = {
      bg: '#0a0a0a',
      surface: '#18181b',
      slime: '#a3e635',
      cyan: '#22d3ee',
      fuchsia: '#d946ef',
      gold: '#facc15',
      grey: '#555555',
      text: '#ffffff',
      paper: '#f5f0e8',
      paperShadow: 'rgba(200,190,170,0.3)',
      crease: '#d4cfc5',
      shelf: '#22d3ee',
    };

    // --- CANVAS ---
    let W, H;
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      W = canvas.width;
      H = canvas.height;
    }
    resize();
    window.addEventListener('resize', resize);

    // --- AUDIO ---
    let audioCtx;
    function initAudio() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === 'suspended') audioCtx.resume();
    }
    canvas.addEventListener('touchstart', initAudio, { once: true });
    canvas.addEventListener('click', initAudio, { once: true });

    function playFold(foldCount) {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.connect(g); g.connect(audioCtx.destination);
      osc.type = 'square';
      osc.frequency.value = 1200 + foldCount * 80;
      g.gain.setValueAtTime(0.1, audioCtx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.04);
      osc.start(); osc.stop(audioCtx.currentTime + 0.04);
      const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.02, audioCtx.sampleRate);
      const data = buf.getChannelData(0);
      for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * (1 - i / data.length) * 0.5;
      const src = audioCtx.createBufferSource();
      const ng = audioCtx.createGain();
      src.buffer = buf; src.connect(ng); ng.connect(audioCtx.destination);
      ng.gain.value = 0.15;
      src.start();
    }

    function playFile() {
      if (!audioCtx) return;
      const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.3, audioCtx.sampleRate);
      const data = buf.getChannelData(0);
      for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * (1 - i / data.length);
      const src = audioCtx.createBufferSource();
      const flt = audioCtx.createBiquadFilter();
      const g = audioCtx.createGain();
      src.buffer = buf;
      flt.type = 'bandpass';
      flt.frequency.setValueAtTime(3000, audioCtx.currentTime);
      flt.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.25);
      flt.Q.value = 2;
      src.connect(flt); flt.connect(g); g.connect(audioCtx.destination);
      g.gain.setValueAtTime(0.12, audioCtx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
      src.start();
    }

    function playStamp() {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.connect(g); g.connect(audioCtx.destination);
      osc.type = 'sine';
      osc.frequency.setValueAtTime(150, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(60, audioCtx.currentTime + 0.08);
      g.gain.setValueAtTime(0.15, audioCtx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
      osc.start(); osc.stop(audioCtx.currentTime + 0.1);
    }

    function playCrumple() {
      if (!audioCtx) return;
      const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.25, audioCtx.sampleRate);
      const data = buf.getChannelData(0);
      for (let i = 0; i < data.length; i++) {
        const env = (1 - i / data.length);
        data[i] = (Math.random() * 2 - 1) * env * env;
      }
      const src = audioCtx.createBufferSource();
      const flt = audioCtx.createBiquadFilter();
      const g = audioCtx.createGain();
      src.buffer = buf;
      flt.type = 'lowpass'; flt.frequency.value = 2000;
      src.connect(flt); flt.connect(g); g.connect(audioCtx.destination);
      g.gain.setValueAtTime(0.2, audioCtx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.25);
      src.start();
    }

    function playLevelUp() {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain); gain.connect(audioCtx.destination);
      osc.type = 'square';
      osc.frequency.setValueAtTime(300, audioCtx.currentTime);
      osc.frequency.linearRampToValueAtTime(600, audioCtx.currentTime + 0.2);
      gain.gain.setValueAtTime(0.12, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
      osc.start(); osc.stop(audioCtx.currentTime + 0.3);
    }

    // --- STAMPS ---
    const STAMP_SYMBOLS = ['★', '✓', '☺', '◆', '♦', '●', '▲', '✦', '⊕', '☆'];
    const STAMP_COLORS = [T.fuchsia, T.gold, T.cyan, T.slime, '#ef4444'];

    // --- CONSTANTS ---
    const PAPER_SIZE = 40;
    const LANDING_TOLERANCE = 25; // ±25 degrees from flat (Dither's spec)
    const TORQUE_FORCE = 8;

    // --- STATE ---
    let paper, shelves, particles, stamps;
    let score, depth, foldCount;
    let gamePhase; // 'start', 'playing', 'tutorial', 'crumple', 'over'
    let deadTimer, gameTime;
    let cameraY;
    let screenShake;
    let fileAnim;
    let crumpleAnim;
    let landedOnShelf; // reference to shelf we're resting on
    let landPauseTimer; // brief pause before tipping off

    // --- TUTORIAL STATE ---
    let tutorialStep;
    let tutorialPhase;
    let tutorialTimer;
    let tutorialLandings;

    const TUTORIAL_STEPS = [
      {
        name: 'FOLD',
        instruction: 'TAP TO FOLD',
        setup() {
          shelves = [];
          particles = [];
          stamps = [];
          foldCount = 0;
          depth = 0; score = 0; cameraY = 0;
          tutorialLandings = 0;
          paper = { x: W / 2, y: 100, vy: 0, vx: 0, angle: 0, angularVel: 0, width: PAPER_SIZE, height: PAPER_SIZE * 0.7 };
          landedOnShelf = null; landPauseTimer = 0;
          // one wide shelf directly below, easy to land on
          shelves.push({
            index: 0, x: W * 0.2, y: 350, width: W * 0.6, height: 6,
            filed: false, fileOffset: 0, windDir: 0, windStrength: 0,
          });
        },
        check() { return tutorialLandings >= 1; },
        successText: 'NICE!',
      },
      {
        name: 'AIM',
        instruction: 'LAND FLAT ON THE SHELF',
        setup() {
          shelves = [];
          particles = [];
          foldCount = 0;
          depth = 0; score = 0; cameraY = 0;
          tutorialLandings = 0;
          paper = { x: W / 2, y: 100, vy: 0, vx: 0, angle: 0.5, angularVel: 1.5, width: PAPER_SIZE, height: PAPER_SIZE * 0.7 };
          landedOnShelf = null; landPauseTimer = 0;
          // start paper already spinning — player must time the fold to land flat
          shelves.push({
            index: 0, x: W * 0.25, y: 380, width: W * 0.5, height: 6,
            filed: false, fileOffset: 0, windDir: 0, windStrength: 0,
          });
          shelves.push({
            index: 1, x: W * 0.2, y: 550, width: W * 0.6, height: 6,
            filed: false, fileOffset: 0, windDir: 0, windStrength: 0,
          });
        },
        check() { return tutorialLandings >= 1; },
        successText: 'FILED!',
      },
      {
        name: 'WIND',
        instruction: 'WIND PUSHES YOU',
        setup() {
          shelves = [];
          particles = [];
          foldCount = 0;
          depth = 0; score = 0; cameraY = 0;
          tutorialLandings = 0;
          paper = { x: W / 2, y: 100, vy: 0, vx: 0, angle: 0, angularVel: 0, width: PAPER_SIZE, height: PAPER_SIZE * 0.7 };
          landedOnShelf = null; landPauseTimer = 0;
          // shelf with wind
          shelves.push({
            index: 0, x: W * 0.15, y: 350, width: W * 0.5, height: 6,
            filed: false, fileOffset: 0, windDir: 1, windStrength: 70,
          });
          shelves.push({
            index: 1, x: W * 0.3, y: 520, width: W * 0.4, height: 6,
            filed: false, fileOffset: 0, windDir: 0, windStrength: 0,
          });
        },
        check() { return tutorialLandings >= 1; },
        successText: 'READY!',
      },
    ];

    function init() {
      paper = {
        x: W / 2, y: 100, vy: 0, vx: 0,
        angle: 0, angularVel: 0,
        width: PAPER_SIZE, height: PAPER_SIZE * 0.7,
      };
      shelves = [];
      particles = [];
      stamps = [];
      score = 0;
      depth = 0;
      foldCount = 0;
      gamePhase = 'start';
      deadTimer = 0;
      gameTime = 0;
      cameraY = 0;
      screenShake = { timer: 0, intensity: 0 };
      fileAnim = null;
      crumpleAnim = null;
      landedOnShelf = null;
      landPauseTimer = 0;
      tutorialStep = -1;
      tutorialPhase = 'instruction';
      tutorialTimer = 0;
      tutorialLandings = 0;

      for (let i = 0; i < 30; i++) {
        shelves.push(createShelf(i));
      }
    }

    function createShelf(index) {
      const baseWidth = W * 0.5;
      const minWidth = W * 0.15;
      const widthDecay = Math.max(minWidth, baseWidth - index * 4);
      const spacing = 150 + Math.min(index * 3, 80);
      const hasWind = index > 8 && Math.random() < 0.2;
      return {
        index,
        x: W * 0.15 + Math.random() * (W * 0.7 - widthDecay),
        y: 300 + index * spacing,
        width: widthDecay,
        height: 6,
        filed: false,
        fileOffset: 0,
        windDir: hasWind ? (Math.random() < 0.5 ? -1 : 1) : 0,
        windStrength: hasWind ? (40 + Math.random() * 60) : 0,
      };
    }

    function getGravity() {
      if (gamePhase === 'tutorial') return 180;
      return 250 + stamps.length * 15 + depth * 5;
    }

    function normalizeAngle(a) {
      a = a % (Math.PI * 2);
      if (a < 0) a += Math.PI * 2;
      return a;
    }

    function isFlat(angle) {
      const deg = (normalizeAngle(angle) * 180 / Math.PI) % 90;
      const fromFlat = Math.min(deg, 90 - deg);
      return fromFlat <= LANDING_TOLERANCE;
    }

    function spawnParticles(x, y, color, count) {
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 30 + Math.random() * 60;
        const life = 0.2 + Math.random() * 0.3;
        particles.push({ x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, r: 1 + Math.random() * 2, color, life, maxLife: life });
      }
    }

    // --- TUTORIAL ---
    function startTutorial() {
      gamePhase = 'tutorial';
      tutorialStep = 0;
      tutorialPhase = 'instruction';
      tutorialTimer = 0;
      initAudio();
      TUTORIAL_STEPS[0].setup();
    }

    function skipTutorial() {
      tutorialStep = -1;
      init();
      startGame();
    }

    function advanceTutorial() {
      tutorialStep++;
      if (tutorialStep >= TUTORIAL_STEPS.length) {
        tutorialStep = -1;
        init();
        startGame();
        return;
      }
      tutorialPhase = 'instruction';
      tutorialTimer = 0;
      TUTORIAL_STEPS[tutorialStep].setup();
    }

    // --- INPUT ---
    function handleStartClick(clientX, clientY) {
      const btnY = H / 2 + 115;
      if (Math.abs(clientY - btnY) < 20 && Math.abs(clientX - W / 2) < 80) {
        startTutorial();
        return;
      }
      startGame();
    }

    function handleTutorialClick(clientX, clientY) {
      if (clientX > W - 80 && clientY < 45) {
        skipTutorial();
        return;
      }
    }

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const t = e.touches[0];
      if (gamePhase === 'start') { handleStartClick(t.clientX, t.clientY); return; }
      if (gamePhase === 'over') { init(); return; }
      if (gamePhase === 'tutorial') {
        handleTutorialClick(t.clientX, t.clientY);
        if (tutorialPhase === 'playing' && !landedOnShelf) {
          paper.angularVel += TORQUE_FORCE;
          foldCount++;
          playFold(foldCount);
        }
        return;
      }
      if (gamePhase === 'playing' && !landedOnShelf) {
        paper.angularVel += TORQUE_FORCE;
        foldCount++;
        playFold(foldCount);
      }
    });
    canvas.addEventListener('click', (e) => {
      if (gamePhase === 'start') { handleStartClick(e.clientX, e.clientY); return; }
      if (gamePhase === 'over') { init(); return; }
      if (gamePhase === 'tutorial') {
        handleTutorialClick(e.clientX, e.clientY);
        if (tutorialPhase === 'playing' && !landedOnShelf) {
          paper.angularVel += TORQUE_FORCE;
          foldCount++;
          playFold(foldCount);
        }
        return;
      }
      if (gamePhase === 'playing' && !landedOnShelf) {
        paper.angularVel += TORQUE_FORCE;
        foldCount++;
        playFold(foldCount);
      }
    });

    function startGame() {
      init();
      initAudio();
      gamePhase = 'playing';
    }

    // --- CORE PHYSICS (shared between game + tutorial) ---
    function updatePaperPhysics(dt) {
      if (landedOnShelf) {
        // brief pause then tip off
        landPauseTimer -= dt;
        if (landPauseTimer <= 0) {
          // push paper toward nearest shelf edge + slight tumble
          const shelfCenter = landedOnShelf.x + landedOnShelf.width / 2;
          const dir = paper.x > shelfCenter ? 1 : -1;
          paper.vx = dir * 40;
          paper.vy = 10;
          paper.angularVel = dir * 0.5;
          landedOnShelf = null;
        }
        return false; // not falling
      }

      const gravity = getGravity();
      paper.vy += gravity * dt;
      paper.vx *= 0.92; // air resistance
      const flutter = Math.sin(gameTime * 3 + paper.y * 0.01) * 15;
      paper.vx += flutter * dt;
      paper.angularVel *= 0.97;

      // wind
      for (const s of shelves) {
        if (s.filed || s.windDir === 0) continue;
        const dist = Math.abs(paper.y - s.y);
        if (dist < 120) {
          const strength = s.windStrength * (1 - dist / 120);
          paper.vx += s.windDir * strength * dt;
        }
      }

      paper.x += paper.vx * dt;
      paper.y += paper.vy * dt;
      paper.angle += paper.angularVel * dt;
      paper.x = Math.max(20, Math.min(W - 20, paper.x));

      return true; // falling
    }

    function checkShelfCollision(isTutorial) {
      for (const s of shelves) {
        if (s.filed) continue;
        const sy = s.y;
        if (paper.y + paper.height / 2 >= sy &&
            paper.y - paper.height / 2 <= sy + s.height &&
            paper.x >= s.x - 5 &&
            paper.x <= s.x + s.width + 5 &&
            paper.vy > 0) {

          if (isFlat(paper.angle)) {
            // CLEAN LANDING
            s.filed = true;
            depth++;
            score += 1 + stamps.length;
            paper.y = sy - paper.height / 2;
            paper.vy = 0;
            paper.vx = 0;
            paper.angularVel = 0;
            const deg = normalizeAngle(paper.angle) * 180 / Math.PI;
            paper.angle = Math.round(deg / 90) * 90 * Math.PI / 180;

            fileAnim = { shelf: s, timer: 0.3 };
            s.fileOffset = 0;
            playFile();

            // stamp after brief delay
            setTimeout(() => {
              stamps.push({
                x: -0.3 + Math.random() * 0.6,
                y: -0.2 + Math.random() * 0.4,
                symbol: STAMP_SYMBOLS[Math.floor(Math.random() * STAMP_SYMBOLS.length)],
                color: STAMP_COLORS[Math.floor(Math.random() * STAMP_COLORS.length)],
                scale: 0.6 + Math.random() * 0.4,
                rotation: (Math.random() - 0.5) * 0.3,
              });
              playStamp();
            }, 200);

            spawnParticles(paper.x, sy, T.cyan, 8);
            screenShake = { timer: 0.08, intensity: 1.5 };

            // rest on shelf briefly, then tip off
            landedOnShelf = s;
            landPauseTimer = 0.4;

            if (isTutorial) tutorialLandings++;
            return 'landed';
          } else {
            // CRUMPLE
            if (!isTutorial) {
              gamePhase = 'crumple';
              deadTimer = 0;
              crumpleAnim = { x: paper.x, y: paper.y, r: 15, vy: -50, rotation: paper.angle };
              playCrumple();
              screenShake = { timer: 0.15, intensity: 3 };
            } else {
              // in tutorial, just bounce off — don't kill
              paper.y = sy - paper.height / 2 - 5;
              paper.vy = -Math.abs(paper.vy) * 0.3;
              screenShake = { timer: 0.08, intensity: 1 };
            }
            return 'crumple';
          }
        }
      }
      return null;
    }

    // --- UPDATE ---
    function update(dt) {
      if (gamePhase === 'start') { gameTime += dt; return; }
      gameTime += dt;

      if (gamePhase === 'tutorial') { updateTutorial(dt); return; }

      if (gamePhase === 'crumple') {
        deadTimer += dt;
        if (crumpleAnim) {
          crumpleAnim.vy += 400 * dt;
          crumpleAnim.y += crumpleAnim.vy * dt;
          crumpleAnim.rotation += 3 * dt;
          crumpleAnim.r = Math.max(5, crumpleAnim.r - 10 * dt);
        }
        if (deadTimer >= 2.0) gamePhase = 'over';
        return;
      }

      if (gamePhase !== 'playing') return;

      const falling = updatePaperPhysics(dt);

      if (falling) {
        checkShelfCollision(false);
      }

      // camera
      const targetCam = paper.y - H * 0.35;
      cameraY += (targetCam - cameraY) * 3 * dt;

      // generate shelves
      const lastShelf = shelves[shelves.length - 1];
      if (lastShelf && lastShelf.y - cameraY < H + 300) {
        shelves.push(createShelf(lastShelf.index + 1));
      }
      while (shelves.length > 0 && shelves[0].y < cameraY - 200) {
        shelves.shift();
      }

      // file animation
      if (fileAnim) {
        fileAnim.timer -= dt;
        fileAnim.shelf.fileOffset = Math.min(1, 1 - fileAnim.timer / 0.3) * -60;
        if (fileAnim.timer <= 0) fileAnim = null;
      }

      if (screenShake.timer > 0) screenShake.timer -= dt;

      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx * dt; p.y += p.vy * dt;
        p.life -= dt;
        if (p.life <= 0) particles.splice(i, 1);
      }
    }

    // --- TUTORIAL UPDATE ---
    function updateTutorial(dt) {
      if (tutorialStep < 0 || tutorialStep >= TUTORIAL_STEPS.length) return;
      const step = TUTORIAL_STEPS[tutorialStep];

      if (tutorialPhase === 'instruction') {
        tutorialTimer += dt;
        if (tutorialTimer >= 1.2) {
          tutorialPhase = 'playing';
          tutorialTimer = 0;
        }
        return;
      }

      if (tutorialPhase === 'playing') {
        const falling = updatePaperPhysics(dt);
        if (falling) checkShelfCollision(true);

        // camera
        const targetCam = paper.y - H * 0.35;
        cameraY += (targetCam - cameraY) * 3 * dt;

        // file animation
        if (fileAnim) {
          fileAnim.timer -= dt;
          fileAnim.shelf.fileOffset = Math.min(1, 1 - fileAnim.timer / 0.3) * -60;
          if (fileAnim.timer <= 0) fileAnim = null;
        }

        if (screenShake.timer > 0) screenShake.timer -= dt;

        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.x += p.vx * dt; p.y += p.vy * dt;
          p.life -= dt;
          if (p.life <= 0) particles.splice(i, 1);
        }

        if (step.check()) {
          tutorialPhase = 'success';
          tutorialTimer = 0;
          playLevelUp();
        }
        return;
      }

      if (tutorialPhase === 'success') {
        tutorialTimer += dt;
        const delay = tutorialStep === TUTORIAL_STEPS.length - 1 ? 1.0 : 0.6;
        if (tutorialTimer >= delay) advanceTutorial();
      }
    }

    // --- DRAW HELPERS ---
    function drawShelvesAndPaper() {
      // shelves
      for (const s of shelves) {
        const sy = s.y - cameraY;
        if (sy < -20 || sy > H + 20) continue;
        const ox = s.filed ? s.fileOffset : 0;
        ctx.fillStyle = s.filed ? T.grey : T.shelf;
        ctx.globalAlpha = s.filed ? 0.3 : 1;
        if (!s.filed) { ctx.shadowBlur = 4; ctx.shadowColor = T.shelf; }
        ctx.fillRect(s.x + ox, sy, s.width, s.height);
        ctx.shadowBlur = 0;
        if (s.windDir !== 0 && !s.filed) {
          ctx.fillStyle = T.fuchsia;
          ctx.globalAlpha = 0.3 + Math.sin(gameTime * 4) * 0.15;
          ctx.font = '12px monospace';
          ctx.textAlign = 'center';
          ctx.fillText(s.windDir > 0 ? '→' : '←', s.x + s.width / 2, sy - 8);
        }
        ctx.globalAlpha = 1;
      }

      // particles
      for (const p of particles) {
        const py = p.y - cameraY;
        ctx.globalAlpha = p.life / p.maxLife;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, py, p.r, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      // paper
      if (gamePhase === 'playing' || gamePhase === 'tutorial') {
        const py = paper.y - cameraY;
        ctx.save();
        ctx.translate(paper.x, py);
        ctx.rotate(paper.angle);
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fillRect(-paper.width / 2 + 3, -paper.height / 2 + 3, paper.width, paper.height);
        ctx.fillStyle = T.paper;
        ctx.fillRect(-paper.width / 2, -paper.height / 2, paper.width, paper.height);
        // creases
        ctx.strokeStyle = T.crease;
        ctx.lineWidth = 0.5;
        const visibleCreases = Math.min(foldCount, 5);
        for (let i = 0; i < visibleCreases; i++) {
          const offset = (i + 1) / (visibleCreases + 1);
          if (i % 2 === 0) {
            const cy = -paper.height / 2 + paper.height * offset;
            ctx.beginPath(); ctx.moveTo(-paper.width / 2, cy); ctx.lineTo(paper.width / 2, cy); ctx.stroke();
          } else {
            const cx = -paper.width / 2 + paper.width * offset;
            ctx.beginPath(); ctx.moveTo(cx, -paper.height / 2); ctx.lineTo(cx, paper.height / 2); ctx.stroke();
          }
        }
        // stamps
        for (const st of stamps) {
          ctx.save();
          ctx.translate(st.x * paper.width, st.y * paper.height);
          ctx.rotate(st.rotation);
          ctx.fillStyle = st.color;
          ctx.globalAlpha = 0.7;
          ctx.font = `${8 * st.scale}px monospace`;
          ctx.textAlign = 'center';
          ctx.fillText(st.symbol, 0, 3);
          ctx.restore();
        }
        ctx.restore();
      }
    }

    // --- DRAW ---
    function draw() {
      ctx.fillStyle = T.bg;
      ctx.fillRect(0, 0, W, H);

      if (gamePhase === 'start') { drawStart(); return; }
      if (gamePhase === 'tutorial') { drawTutorial(); return; }
      if (gamePhase === 'over') { drawGameOver(); return; }

      // cabinet lines
      ctx.strokeStyle = '#151515';
      ctx.lineWidth = 1;
      for (let x = W * 0.1; x < W * 0.9; x += W * 0.8) {
        const startY = Math.max(0, -cameraY % 100);
        for (let y = startY; y < H; y += 100) {
          ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, y + 60); ctx.stroke();
        }
      }

      ctx.save();
      if (screenShake.timer > 0) {
        const s = screenShake.intensity * (screenShake.timer / 0.15);
        ctx.translate((Math.random() * 2 - 1) * s, (Math.random() * 2 - 1) * s);
      }

      drawShelvesAndPaper();

      // crumple
      if (gamePhase === 'crumple' && crumpleAnim) {
        const cy = crumpleAnim.y - cameraY;
        ctx.save();
        ctx.translate(crumpleAnim.x, cy);
        ctx.rotate(crumpleAnim.rotation);
        ctx.fillStyle = '#a09880';
        ctx.beginPath();
        ctx.arc(0, 0, crumpleAnim.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#80756a';
        ctx.lineWidth = 0.5;
        for (let i = 0; i < 4; i++) {
          const a = i * Math.PI / 2 + crumpleAnim.rotation;
          ctx.beginPath(); ctx.moveTo(0, 0);
          ctx.lineTo(Math.cos(a) * crumpleAnim.r * 0.8, Math.sin(a) * crumpleAnim.r * 0.8);
          ctx.stroke();
        }
        ctx.restore();
      }

      ctx.restore();

      // HUD
      ctx.fillStyle = T.text;
      ctx.font = 'bold 28px monospace';
      ctx.textAlign = 'left';
      ctx.fillText(score + '', 16, 40);
      ctx.font = '14px monospace';
      ctx.fillStyle = T.grey;
      ctx.fillText('depth ' + depth, 16, 60);
      ctx.textAlign = 'right';
      ctx.fillStyle = T.paper;
      ctx.font = '12px monospace';
      ctx.fillText('folds: ' + foldCount, W - 16, 30);
      ctx.fillStyle = T.fuchsia;
      ctx.fillText('stamps: ' + stamps.length, W - 16, 48);

      if (gamePhase === 'crumple') {
        const t = Math.min(deadTimer / 1.5, 1);
        ctx.fillStyle = `rgba(0,0,0,${t * 0.6})`;
        ctx.fillRect(0, 0, W, H);
        ctx.fillStyle = T.text;
        ctx.font = 'bold 32px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('CRUMPLED', W / 2, H / 2 - 10);
      }

      ctx.textAlign = 'left';
    }

    // --- TUTORIAL DRAW ---
    function drawTutorial() {
      if (tutorialStep < 0 || tutorialStep >= TUTORIAL_STEPS.length) return;
      const step = TUTORIAL_STEPS[tutorialStep];

      ctx.fillStyle = T.bg;
      ctx.fillRect(0, 0, W, H);

      ctx.save();
      if (screenShake.timer > 0) {
        const s = screenShake.intensity * (screenShake.timer / 0.15);
        ctx.translate((Math.random() * 2 - 1) * s, (Math.random() * 2 - 1) * s);
      }
      drawShelvesAndPaper();
      ctx.restore();

      // step counter
      ctx.fillStyle = 'rgba(255,255,255,0.4)';
      ctx.font = '14px monospace';
      ctx.textAlign = 'left';
      ctx.fillText((tutorialStep + 1) + '/' + TUTORIAL_STEPS.length, 16, 30);

      // instruction
      if (tutorialPhase === 'instruction' || tutorialPhase === 'playing') {
        ctx.fillStyle = T.text;
        ctx.font = 'bold 22px monospace';
        ctx.textAlign = 'center';
        ctx.fillText(step.instruction, W / 2, 50);
      }

      // success
      if (tutorialPhase === 'success') {
        ctx.fillStyle = T.slime;
        ctx.font = 'bold 36px monospace';
        ctx.textAlign = 'center';
        ctx.shadowBlur = 12;
        ctx.shadowColor = T.slime;
        ctx.fillText(step.successText, W / 2, H / 2 - 20);
        ctx.shadowBlur = 0;
      }

      // SKIP
      ctx.fillStyle = 'rgba(255,255,255,0.3)';
      ctx.font = '14px monospace';
      ctx.textAlign = 'right';
      ctx.fillText('SKIP >', W - 16, 30);

      ctx.textAlign = 'left';
    }

    function drawStart() {
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(0, 0, W, H);
      ctx.textAlign = 'center';

      const bobY = Math.sin(gameTime * 1.5) * 10;
      const bobAngle = Math.sin(gameTime * 0.8) * 0.15;
      ctx.save();
      ctx.translate(W / 2, H / 2 - 70 + bobY);
      ctx.rotate(bobAngle);
      ctx.fillStyle = T.paper;
      ctx.fillRect(-25, -18, 50, 36);
      ctx.strokeStyle = T.crease;
      ctx.lineWidth = 0.5;
      ctx.beginPath(); ctx.moveTo(-25, 0); ctx.lineTo(25, 0); ctx.stroke();
      ctx.restore();

      ctx.fillStyle = T.slime;
      ctx.font = 'bold 48px monospace';
      ctx.shadowBlur = 16;
      ctx.shadowColor = T.slime;
      ctx.fillText('FOLD', W / 2, H / 2 - 15);
      ctx.shadowBlur = 0;

      ctx.fillStyle = T.text;
      ctx.font = '16px monospace';
      ctx.fillText('Tap to fold • Land flat on shelves', W / 2, H / 2 + 15);
      ctx.fillText('Bad angle = crumple', W / 2, H / 2 + 38);

      ctx.fillStyle = T.slime;
      ctx.font = '20px monospace';
      ctx.fillText('[ TAP TO START ]', W / 2, H / 2 + 85);

      // TUTORIAL button
      ctx.fillStyle = 'rgba(255,255,255,0.5)';
      ctx.font = '16px monospace';
      ctx.fillText('[ TUTORIAL ]', W / 2, H / 2 + 115);

      ctx.textAlign = 'left';
    }

    function drawGameOver() {
      ctx.fillStyle = 'rgba(0,0,0,0.85)';
      ctx.fillRect(0, 0, W, H);
      ctx.textAlign = 'center';

      ctx.fillStyle = T.gold;
      ctx.font = 'bold 56px monospace';
      ctx.shadowBlur = 12;
      ctx.shadowColor = T.gold;
      ctx.fillText(score + '', W / 2, H / 2 - 50);
      ctx.shadowBlur = 0;

      ctx.fillStyle = T.text;
      ctx.font = '16px monospace';
      ctx.fillText('depth: ' + depth + '  |  stamps: ' + stamps.length, W / 2, H / 2 - 10);
      ctx.fillText('folds: ' + foldCount, W / 2, H / 2 + 15);

      ctx.fillStyle = T.slime;
      ctx.font = '20px monospace';
      ctx.fillText('[ TAP TO RETRY ]', W / 2, H / 2 + 65);

      ctx.textAlign = 'left';
    }

    // --- LOOP ---
    let lastTime = performance.now();
    init();

    function loop(ts) {
      const dt = Math.min((ts - lastTime) / 1000, 0.05);
      lastTime = ts;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
  </script>
</body>
</html>
